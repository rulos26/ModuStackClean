#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Gestor de Archivos de Descargas
Un programa para gestionar y organizar archivos en la carpeta de descargas
"""

import os
import shutil
import datetime
from pathlib import Path
import sys
import time
import subprocess
import platform
import getpass

class GestorDescargas:
    def __init__(self):
        # Obtener la ruta de la carpeta de descargas seg√∫n el sistema operativo
        if sys.platform == "win32":
            self.descargas_path = Path.home() / "Downloads"
        elif sys.platform == "darwin":  # macOS
            self.descargas_path = Path.home() / "Downloads"
        else:  # Linux
            self.descargas_path = Path.home() / "Downloads"
        
        # Crear la carpeta si no existe
        self.descargas_path.mkdir(exist_ok=True)
        
        # Extensiones por categor√≠a
        self.categorias = {
            "imagenes": [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp", ".tiff", ".tif", ".ico", ".psd", ".ai", ".eps"],
            "documentos": [".pdf", ".doc", ".docx", ".txt", ".rtf", ".odt", ".xls", ".xlsx", ".ppt", ".pptx", ".csv", ".xml", ".json"],
            "videos": [".mp4", ".avi", ".mov", ".wmv", ".flv", ".mkv", ".webm", ".m4v", ".3gp", ".mpg", ".mpeg", ".ts"],
            "audio": [".mp3", ".wav", ".flac", ".aac", ".ogg", ".wma", ".m4a", ".opus", ".aiff", ".mid", ".midi"],
            "comprimidos": [".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz", ".cab", ".iso"],
            "ejecutables": [".exe", ".msi", ".dmg", ".pkg", ".deb", ".rpm", ".app", ".bat", ".cmd", ".sh", ".dll", ".sys"],
            "otros": []
        }

    def mostrar_archivos(self, mostrar_ocultos=False):
        """Muestra todos los archivos en la carpeta de descargas"""
        print(f"\nüìÅ Contenido de la carpeta: {self.descargas_path}")
        print("=" * 60)
        
        if not self.descargas_path.exists():
            print("‚ùå La carpeta de descargas no existe")
            return
        
        archivos = []
        for item in self.descargas_path.iterdir():
            if not mostrar_ocultos and item.name.startswith('.'):
                continue
            
            if item.is_file():
                tama√±o = item.stat().st_size
                fecha_mod = datetime.datetime.fromtimestamp(item.stat().st_mtime)
                archivos.append({
                    'nombre': item.name,
                    'tama√±o': tama√±o,
                    'fecha': fecha_mod,
                    'extension': self.obtener_extension_real(item.name)
                })
        
        if not archivos:
            print("üì≠ No hay archivos en la carpeta de descargas")
            return
        
        # Ordenar por fecha de modificaci√≥n (m√°s recientes primero)
        archivos.sort(key=lambda x: x['fecha'], reverse=True)
        
        print(f"{'Nombre':<30} {'Tama√±o':<12} {'Fecha':<20} {'Tipo':<10}")
        print("-" * 80)
        
        for archivo in archivos:
            nombre = archivo['nombre'][:28] + ".." if len(archivo['nombre']) > 30 else archivo['nombre']
            tama√±o = self.formatear_tama√±o(archivo['tama√±o'])
            fecha = archivo['fecha'].strftime("%d/%m/%Y %H:%M")
            tipo = self.obtener_tipo_archivo(archivo['extension'])
            
            print(f"{nombre:<30} {tama√±o:<12} {fecha:<20} {tipo:<10}")
        
        print(f"\nüìä Total de archivos: {len(archivos)}")
        self.mostrar_estadisticas(archivos)

    def formatear_tama√±o(self, bytes_size):
        """Convierte bytes a formato legible"""
        if bytes_size == 0:
            return "0 B"
        
        unidades = ['B', 'KB', 'MB', 'GB', 'TB']
        i = 0
        while bytes_size >= 1024 and i < len(unidades) - 1:
            bytes_size /= 1024.0
            i += 1
        
        return f"{bytes_size:.1f} {unidades[i]}"

    def obtener_tipo_archivo(self, extension):
        """Determina el tipo de archivo basado en su extensi√≥n"""
        for categoria, extensiones in self.categorias.items():
            if extension in extensiones:
                return categoria
        return "otro"

    def obtener_extension_real(self, nombre_archivo):
        """Obtiene la extensi√≥n real del archivo, manejando nombres problem√°ticos"""
        # Primero intentar obtener la extensi√≥n al final del nombre
        extension = Path(nombre_archivo).suffix.lower()
        
        # Si no hay extensi√≥n o es muy larga, buscar extensiones conocidas en todo el nombre
        if not extension or len(extension) > 10:
            # Lista completa de extensiones conocidas
            extensiones_conocidas = [
                # Documentos
                ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
                ".txt", ".rtf", ".odt", ".csv", ".xml", ".json",
                # Im√°genes
                ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp", 
                ".tiff", ".tif", ".ico", ".psd", ".ai", ".eps",
                # Videos
                ".mp4", ".avi", ".mov", ".wmv", ".flv", ".mkv", ".webm", 
                ".m4v", ".3gp", ".mpg", ".mpeg", ".ts",
                # Audio
                ".mp3", ".wav", ".flac", ".aac", ".ogg", ".wma", ".m4a", 
                ".opus", ".aiff", ".mid", ".midi",
                # Comprimidos
                ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz", ".cab", ".iso",
                # Ejecutables
                ".exe", ".msi", ".dmg", ".pkg", ".deb", ".rpm", ".app", 
                ".bat", ".cmd", ".sh", ".dll", ".sys"
            ]
            
            # Buscar la extensi√≥n m√°s larga que aparezca en el nombre
            extension_encontrada = ""
            for ext in extensiones_conocidas:
                if ext in nombre_archivo.lower():
                    # Si encontramos una extensi√≥n m√°s larga, la usamos
                    if len(ext) > len(extension_encontrada):
                        extension_encontrada = ext
            
            if extension_encontrada:
                return extension_encontrada
        
        return extension

    def obtener_subcategoria_documento(self, extension):
        """Determina la subcategor√≠a de documento basado en su extensi√≥n"""
        subcategorias_documentos = {
            "pdf": [".pdf"],
            "word": [".doc", ".docx"],
            "excel": [".xls", ".xlsx"],
            "powerpoint": [".ppt", ".pptx"],
            "texto": [".txt", ".rtf", ".odt"],
            "datos": [".csv", ".xml", ".json"],
            "otros": []
        }
        
        for subcategoria, extensiones in subcategorias_documentos.items():
            if extension in extensiones:
                return subcategoria
        return "otros"

    def mostrar_estadisticas(self, archivos):
        """Muestra estad√≠sticas de los archivos"""
        if not archivos:
            return
        
        # Contar por tipo
        tipos = {}
        tama√±o_total = 0
        
        for archivo in archivos:
            tipo = self.obtener_tipo_archivo(archivo['extension'])
            tipos[tipo] = tipos.get(tipo, 0) + 1
            tama√±o_total += archivo['tama√±o']
        
        print(f"\nüìà Estad√≠sticas:")
        print(f"Tama√±o total: {self.formatear_tama√±o(tama√±o_total)}")
        print("\nArchivos por tipo:")
        for tipo, cantidad in sorted(tipos.items()):
            print(f"  {tipo.capitalize()}: {cantidad}")

    def buscar_archivos(self, termino):
        """Busca archivos que contengan el t√©rmino especificado"""
        print(f"\nüîç Buscando archivos que contengan: '{termino}'")
        print("=" * 60)
        
        encontrados = []
        for item in self.descargas_path.iterdir():
            if item.is_file() and termino.lower() in item.name.lower():
                tama√±o = item.stat().st_size
                fecha_mod = datetime.datetime.fromtimestamp(item.stat().st_mtime)
                encontrados.append({
                    'nombre': item.name,
                    'tama√±o': tama√±o,
                    'fecha': fecha_mod,
                    'ruta': str(item)
                })
        
        if not encontrados:
            print("‚ùå No se encontraron archivos con ese t√©rmino")
            return
        
        print(f"‚úÖ Se encontraron {len(encontrados)} archivos:")
        for archivo in encontrados:
            print(f"  üìÑ {archivo['nombre']} ({self.formatear_tama√±o(archivo['tama√±o'])})")

    def organizar_archivos(self):
        """Organiza los archivos en subcarpetas por tipo"""
        print("\nüóÇÔ∏è Organizando archivos por tipo...")
        
        # Buscar archivos en la carpeta ra√≠z y en subcarpetas existentes
        archivos_a_organizar = []
        
        # Buscar en carpeta ra√≠z
        for item in self.descargas_path.iterdir():
            if item.is_file():
                archivos_a_organizar.append(item)
        
        # Buscar en subcarpetas existentes (para reorganizar si es necesario)
        for item in self.descargas_path.iterdir():
            if item.is_dir() and item.name in self.categorias:
                # Solo buscar en carpetas de categor√≠as conocidas
                for subitem in item.iterdir():
                    if subitem.is_file():
                        archivos_a_organizar.append(subitem)
        
        if not archivos_a_organizar:
            print("üì≠ No hay archivos para organizar")
            return
        
        print(f"üìä Encontrados {len(archivos_a_organizar)} archivos para organizar")
        
        for item in archivos_a_organizar:
            extension = self.obtener_extension_real(item.name)
            categoria = self.obtener_tipo_archivo(extension)
            
            # Crear carpeta de categor√≠a si no existe
            carpeta_categoria = self.descargas_path / categoria
            carpeta_categoria.mkdir(exist_ok=True)
            
            # Mover archivo a la carpeta correspondiente
            destino = carpeta_categoria / item.name
            if not destino.exists():
                if self.mover_archivo_con_reintentos(item, destino):
                    print(f"  ‚úÖ {item.name} ‚Üí {categoria}/")
                else:
                    print(f"  ‚ùå No se pudo mover {item.name} (archivo en uso)")
            else:
                # Manejar archivo duplicado
                self.manejar_archivo_duplicado(item, carpeta_categoria, categoria)
        
        print("‚úÖ Organizaci√≥n completada")

    def manejar_archivo_duplicado(self, archivo, carpeta_destino, categoria):
        """Maneja archivos duplicados preguntando al usuario qu√© hacer"""
        print(f"\n‚ö†Ô∏è  ARCHIVO DUPLICADO DETECTADO:")
        print(f"   üìÑ Archivo: {archivo.name}")
        print(f"   üìÇ Destino: {categoria}/")
        print(f"   ‚ùå Ya existe un archivo con el mismo nombre")
        
        print("\n¬øQu√© quieres hacer?")
        print("1. üìù Cambiar nombre autom√°ticamente (agregar versi√≥n)")
        print("2. üîÑ Sobrescribir el archivo existente")
        print("3. ‚ùå Saltar este archivo")
        
        while True:
            opcion = input("\nSelecciona una opci√≥n (1-3): ").strip()
            
            if opcion == "1":
                # Cambiar nombre autom√°ticamente
                nuevo_nombre = self.generar_nombre_unico(archivo.name, carpeta_destino)
                nuevo_destino = carpeta_destino / nuevo_nombre
                
                if self.mover_archivo_con_reintentos(archivo, nuevo_destino):
                    print(f"  ‚úÖ {archivo.name} ‚Üí {categoria}/{nuevo_nombre}")
                else:
                    print(f"  ‚ùå No se pudo mover {archivo.name} (archivo en uso)")
                break
                
            elif opcion == "2":
                # Sobrescribir archivo existente
                confirmar = input("‚ö†Ô∏è ¬øEst√°s seguro de que quieres sobrescribir el archivo existente? (s/n): ").lower()
                if confirmar == 's':
                    if self.mover_archivo_con_reintentos(archivo, carpeta_destino / archivo.name):
                        print(f"  ‚úÖ {archivo.name} ‚Üí {categoria}/ (sobrescrito)")
                    else:
                        print(f"  ‚ùå No se pudo mover {archivo.name} (archivo en uso)")
                else:
                    print(f"  ‚è≠Ô∏è Saltando {archivo.name}")
                break
                
            elif opcion == "3":
                # Saltar archivo
                print(f"  ‚è≠Ô∏è Saltando {archivo.name}")
                break
                
            else:
                print("‚ùå Opci√≥n no v√°lida. Por favor selecciona 1, 2 o 3")

    def generar_nombre_unico(self, nombre_original, carpeta_destino):
        """Genera un nombre √∫nico para el archivo agregando versi√≥n"""
        # Separar nombre y extensi√≥n
        nombre_base = Path(nombre_original).stem
        extension = Path(nombre_original).suffix
        
        # Buscar la siguiente versi√≥n disponible
        version = 1
        while True:
            nuevo_nombre = f"{nombre_base}_v{version}{extension}"
            if not (carpeta_destino / nuevo_nombre).exists():
                return nuevo_nombre
            version += 1

    def intentar_cerrar_procesos_archivo(self, ruta_archivo):
        """Intenta cerrar procesos que est√©n usando un archivo espec√≠fico"""
        try:
            if sys.platform == "win32":
                # En Windows, usar handle.exe para encontrar y cerrar procesos
                nombre_archivo = Path(ruta_archivo).name
                
                # Buscar procesos que est√©n usando el archivo
                try:
                    # Usar tasklist para encontrar procesos
                    resultado = subprocess.run(
                        ['tasklist', '/FI', f'IMAGENAME eq *'], 
                        capture_output=True, 
                        text=True, 
                        timeout=10
                    )
                    
                    if resultado.returncode == 0:
                        procesos = resultado.stdout.split('\n')
                        procesos_cerrados = []
                        
                        for proceso in procesos:
                            if nombre_archivo.lower() in proceso.lower():
                                # Extraer el nombre del proceso
                                partes = proceso.split()
                                if len(partes) >= 1:
                                    nombre_proceso = partes[0]
                                    if nombre_proceso not in ['IMAGENAME', '=']:
                                        try:
                                            # Intentar cerrar el proceso
                                            subprocess.run(['taskkill', '/F', '/IM', nombre_proceso], 
                                                         capture_output=True, timeout=5)
                                            procesos_cerrados.append(nombre_proceso)
                                        except:
                                            pass
                        
                        if procesos_cerrados:
                            print(f"  üîÑ Procesos cerrados: {', '.join(procesos_cerrados)}")
                            return True
                            
                except subprocess.TimeoutExpired:
                    pass
                except Exception as e:
                    pass
                    
            else:
                # En Linux/macOS, usar lsof y kill
                try:
                    resultado = subprocess.run(
                        ['lsof', ruta_archivo], 
                        capture_output=True, 
                        text=True, 
                        timeout=10
                    )
                    
                    if resultado.returncode == 0:
                        lineas = resultado.stdout.strip().split('\n')
                        if len(lineas) > 1:  # Hay procesos usando el archivo
                            for linea in lineas[1:]:  # Saltar la primera l√≠nea (header)
                                partes = linea.split()
                                if len(partes) >= 2:
                                    pid = partes[1]
                                    try:
                                        subprocess.run(['kill', '-9', pid], 
                                                     capture_output=True, timeout=5)
                                        print(f"  üîÑ Proceso cerrado: PID {pid}")
                                    except:
                                        pass
                            return True
                            
                except subprocess.TimeoutExpired:
                    pass
                except Exception as e:
                    pass
                    
        except Exception as e:
            pass
            
        return False

    def mover_archivo_con_reintentos(self, origen, destino, max_reintentos=3):
        """Mueve un archivo con reintentos si est√° siendo usado"""
        for intento in range(max_reintentos):
            try:
                shutil.move(str(origen), str(destino))
                return True
            except PermissionError as e:
                if "El proceso no tiene acceso al archivo" in str(e) or "being used by another process" in str(e):
                    if intento < max_reintentos - 1:  # No es el √∫ltimo intento
                        print(f"  ‚ö†Ô∏è Archivo en uso, intentando cerrar procesos... (intento {intento + 1}/{max_reintentos})")
                        
                        # Intentar cerrar procesos que usen el archivo
                        if self.intentar_cerrar_procesos_archivo(str(origen)):
                            print(f"  ‚è≥ Esperando 2 segundos...")
                            time.sleep(2)  # Esperar un poco
                            continue
                        else:
                            print(f"  ‚ùå No se pudieron cerrar los procesos que usan el archivo")
                            return False
                    else:
                        print(f"  ‚ùå No se pudo mover el archivo despu√©s de {max_reintentos} intentos")
                        return False
                else:
                    # Otro tipo de PermissionError
                    raise e
            except Exception as e:
                raise e
        
        return False

    def limpiar_archivos_antiguos(self, dias=30):
        """Elimina archivos m√°s antiguos que el n√∫mero de d√≠as especificado"""
        print(f"\nüßπ Limpiando archivos m√°s antiguos de {dias} d√≠as...")
        
        fecha_limite = datetime.datetime.now() - datetime.timedelta(days=dias)
        eliminados = 0
        
        for item in self.descargas_path.iterdir():
            if item.is_file():
                fecha_mod = datetime.datetime.fromtimestamp(item.stat().st_mtime)
                if fecha_mod < fecha_limite:
                    try:
                        item.unlink()
                        print(f"  üóëÔ∏è Eliminado: {item.name}")
                        eliminados += 1
                    except Exception as e:
                        print(f"  ‚ùå Error eliminando {item.name}: {e}")
        
        print(f"‚úÖ Se eliminaron {eliminados} archivos")

    def organizacion_automatica_completa(self):
        """Organizaci√≥n autom√°tica completa con informaci√≥n detallada"""
        print("\nüéØ ORGANIZACI√ìN AUTOM√ÅTICA COMPLETA")
        print("=" * 60)
        print("üìÇ Esta funci√≥n organizar√° todos los archivos en carpetas por tipo:")
        print("   üñºÔ∏è  im√°genes/     - Fotos y gr√°ficos")
        print("   üìÑ documentos/    - PDFs, Word, textos (con suborganizaci√≥n)")
        print("   üéµ audio/         - M√∫sica y archivos de sonido")
        print("   üé¨ videos/        - Pel√≠culas y clips")
        print("   üì¶ comprimidos/   - Archivos ZIP, RAR, etc.")
        print("   ‚öôÔ∏è  ejecutables/   - Programas y instaladores")
        print("   üìÅ otros/         - Archivos no clasificados")
        print("=" * 60)
        print("üìã Los documentos se suborganizar√°n por extensi√≥n:")
        print("   üìÑ documentos/pdf/     - Archivos PDF")
        print("   üìÑ documentos/word/    - Archivos Word (.doc, .docx)")
        print("   üìÑ documentos/excel/   - Archivos Excel (.xls, .xlsx)")
        print("   üìÑ documentos/powerpoint/ - Archivos PowerPoint (.ppt, .pptx)")
        print("   üìÑ documentos/texto/   - Archivos de texto (.txt, .rtf)")
        print("   üìÑ documentos/datos/   - Archivos de datos (.csv, .xml, .json)")
        print("   üìÑ documentos/otros/   - Otros documentos")
        
        # Contar archivos antes de organizar (incluyendo subcarpetas)
        archivos_antes = []
        
        # Buscar en carpeta ra√≠z
        for item in self.descargas_path.iterdir():
            if item.is_file():
                archivos_antes.append(item)
        
        # Buscar en subcarpetas existentes
        for item in self.descargas_path.iterdir():
            if item.is_dir() and item.name in self.categorias:
                # Solo buscar en carpetas de categor√≠as conocidas
                for subitem in item.iterdir():
                    if subitem.is_file():
                        archivos_antes.append(subitem)
        
        if not archivos_antes:
            print("üì≠ No hay archivos para organizar en la carpeta de descargas")
            return
        
        print(f"\nüìä Archivos encontrados: {len(archivos_antes)}")
        
        # Mostrar archivos que se van a organizar
        print("\nüìã Archivos que se organizar√°n:")
        for archivo in archivos_antes:
            extension = self.obtener_extension_real(archivo.name)
            tipo = self.obtener_tipo_archivo(extension)
            
            if tipo == "documentos":
                subcategoria = self.obtener_subcategoria_documento(extension)
                print(f"  üìÑ {archivo.name} ‚Üí {tipo}/{subcategoria}/")
            else:
                print(f"  üìÑ {archivo.name} ‚Üí {tipo}/")
        
        # Confirmar organizaci√≥n
        confirmar = input(f"\n¬øEst√°s seguro de que quieres organizar {len(archivos_antes)} archivos? (s/n): ").lower()
        if confirmar != 's':
            print("‚ùå Organizaci√≥n cancelada")
            return
        
        # Realizar la organizaci√≥n
        print("\nüóÇÔ∏è Organizando archivos...")
        organizados = 0
        errores = 0
        
        for item in archivos_antes:
            if item.is_file():
                extension = self.obtener_extension_real(item.name)
                categoria = self.obtener_tipo_archivo(extension)
                
                # Crear carpeta de categor√≠a si no existe
                carpeta_categoria = self.descargas_path / categoria
                carpeta_categoria.mkdir(exist_ok=True)
                
                # Si es un documento, crear subcarpeta
                if categoria == "documentos":
                    subcategoria = self.obtener_subcategoria_documento(extension)
                    carpeta_destino = carpeta_categoria / subcategoria
                    carpeta_destino.mkdir(exist_ok=True)
                    destino = carpeta_destino / item.name
                    ruta_mostrar = f"{categoria}/{subcategoria}/"
                else:
                    destino = carpeta_categoria / item.name
                    ruta_mostrar = f"{categoria}/"
                
                if not destino.exists():
                    if self.mover_archivo_con_reintentos(item, destino):
                        print(f"  ‚úÖ {item.name} ‚Üí {ruta_mostrar}")
                        organizados += 1
                    else:
                        print(f"  ‚ùå No se pudo mover {item.name} (archivo en uso)")
                        errores += 1
                else:
                    # Manejar archivo duplicado en organizaci√≥n autom√°tica
                    print(f"\n‚ö†Ô∏è  ARCHIVO DUPLICADO: {item.name} ya existe en {ruta_mostrar}")
                    
                    # Preguntar qu√© hacer con el duplicado
                    print("¬øQu√© quieres hacer?")
                    print("1. üìù Cambiar nombre autom√°ticamente (agregar versi√≥n)")
                    print("2. üîÑ Sobrescribir el archivo existente")
                    print("3. ‚ùå Saltar este archivo")
                    
                    while True:
                        opcion = input("Selecciona una opci√≥n (1-3): ").strip()
                        
                        if opcion == "1":
                            # Cambiar nombre autom√°ticamente
                            nuevo_nombre = self.generar_nombre_unico(item.name, carpeta_destino)
                            nuevo_destino = carpeta_destino / nuevo_nombre
                            
                            if self.mover_archivo_con_reintentos(item, nuevo_destino):
                                print(f"  ‚úÖ {item.name} ‚Üí {ruta_mostrar}{nuevo_nombre}")
                                organizados += 1
                            else:
                                print(f"  ‚ùå No se pudo mover {item.name} (archivo en uso)")
                                errores += 1
                            break
                           
                        elif opcion == "2":
                            # Sobrescribir archivo existente
                            confirmar = input("‚ö†Ô∏è ¬øEst√°s seguro de que quieres sobrescribir el archivo existente? (s/n): ").lower()
                            if confirmar == 's':
                                if self.mover_archivo_con_reintentos(item, destino):
                                    print(f"  ‚úÖ {item.name} ‚Üí {ruta_mostrar} (sobrescrito)")
                                    organizados += 1
                                else:
                                    print(f"  ‚ùå No se pudo mover {item.name} (archivo en uso)")
                                    errores += 1
                            else:
                                print(f"  ‚è≠Ô∏è Saltando {item.name}")
                                errores += 1
                            break
                        
                        elif opcion == "3":
                            # Saltar archivo
                            print(f"  ‚è≠Ô∏è Saltando {item.name}")
                            errores += 1
                            break
                            
                        else:
                            print("‚ùå Opci√≥n no v√°lida. Por favor selecciona 1, 2 o 3")
        
        # Mostrar resumen
        print("\n" + "=" * 60)
        print("üìà RESUMEN DE ORGANIZACI√ìN")
        print("=" * 60)
        print(f"‚úÖ Archivos organizados exitosamente: {organizados}")
        if errores > 0:
            print(f"‚ö†Ô∏è Archivos con problemas: {errores}")
        
        # Mostrar estructura final
        print(f"\nüìÅ Estructura final de carpetas creadas:")
        for categoria in self.categorias.keys():
            carpeta = self.descargas_path / categoria
            if carpeta.exists():
                if categoria == "documentos":
                    # Contar archivos en subcarpetas de documentos
                    total_documentos = 0
                    subcarpetas_con_archivos = []
                    for subcarpeta in carpeta.iterdir():
                        if subcarpeta.is_dir():
                            archivos_en_subcarpeta = len([f for f in subcarpeta.iterdir() if f.is_file()])
                            if archivos_en_subcarpeta > 0:
                                total_documentos += archivos_en_subcarpeta
                                subcarpetas_con_archivos.append(f"    üìÑ {subcarpeta.name}/ - {archivos_en_subcarpeta} archivos")
                    
                    if total_documentos > 0:
                        print(f"  üìÇ {categoria}/ - {total_documentos} archivos")
                        for subcarpeta_info in subcarpetas_con_archivos:
                            print(subcarpeta_info)
                else:
                    archivos_en_carpeta = len([f for f in carpeta.iterdir() if f.is_file()])
                    if archivos_en_carpeta > 0:
                        print(f"  üìÇ {categoria}/ - {archivos_en_carpeta} archivos")
        
        print("\nüéâ ¬°Organizaci√≥n completada!")
        print("üí° Los archivos est√°n ahora organizados en carpetas por tipo")
        print("üîç Puedes usar la opci√≥n 1 para ver la nueva estructura")

    def mostrar_info_sistema(self):
        """Muestra informaci√≥n del sistema"""
        print("\n" + "=" * 60)
        print("üíª INFORMACI√ìN DEL SISTEMA")
        print("=" * 60)
        
        # Informaci√≥n b√°sica del sistema
        print(f"üíª Sistema Operativo: {platform.system()} {platform.version()}")
        print(f"üèóÔ∏è  Arquitectura: {platform.machine()}")
        print(f"üë§ Usuario: {getpass.getuser()}")
        print(f"üñ•Ô∏è  Hostname: {platform.node()}")
        print(f"üêç Python: {sys.version.split()[0]}")
        
        # Informaci√≥n de CPU
        try:
            import psutil
            cpu_count = psutil.cpu_count()
            cpu_percent = psutil.cpu_percent(interval=1)
            print(f"‚ö° CPU: {cpu_count} n√∫cleos - Uso actual: {cpu_percent}%")
        except ImportError:
            print("‚ö° CPU: Informaci√≥n no disponible (psutil no instalado)")
        
        # Informaci√≥n de memoria
        try:
            import psutil
            memoria = psutil.virtual_memory()
            print(f"üíæ RAM: {self.formatear_tama√±o(memoria.total)} - Usado: {memoria.percent}%")
        except ImportError:
            print("üíæ RAM: Informaci√≥n no disponible (psutil no instalado)")
        
        # Informaci√≥n de disco
        try:
            import psutil
            disco = psutil.disk_usage(str(self.descargas_path))
            print(f"üíø Disco: {self.formatear_tama√±o(disco.total)} - Libre: {self.formatear_tama√±o(disco.free)}")
        except ImportError:
            print("üíø Disco: Informaci√≥n no disponible (psutil no instalado)")
        
        # Informaci√≥n de red
        try:
            import socket
            hostname = socket.gethostname()
            ip_local = socket.gethostbyname(hostname)
            print(f"üåê IP Local: {ip_local}")
        except:
            print("üåê IP Local: No disponible")
        
        print("\nüí° Para informaci√≥n m√°s detallada, ejecuta: python info_sistema.py")
        print("üì¶ Para instalar dependencias: python instalar_dependencias_python.py")

def mostrar_menu():
    """Muestra el men√∫ principal del programa"""
    print("\n" + "=" * 50)
    print("üìÅ GESTOR DE ARCHIVOS DE DESCARGAS")
    print("=" * 50)
    print("1. üìã Ver todos los archivos")
    print("2. üîç Buscar archivos")
    print("3. üóÇÔ∏è Organizar archivos por tipo")
    print("4. üßπ Limpiar archivos antiguos")
    print("5. üìä Ver estad√≠sticas")
    print("6. üéØ Organizaci√≥n autom√°tica completa")
    print("7. üíª Informaci√≥n del sistema")
    print("8. ‚ùå Salir")
    print("=" * 50)

def main():
    """Funci√≥n principal del programa"""
    gestor = GestorDescargas()
    
    print("üöÄ Bienvenido al Gestor de Archivos de Descargas")
    print(f"üìÇ Carpeta de descargas: {gestor.descargas_path}")
    
    while True:
        mostrar_menu()
        
        try:
            opcion = input("\nSelecciona una opci√≥n (1-8): ").strip()
            
            if opcion == "1":
                mostrar_ocultos = input("¬øMostrar archivos ocultos? (s/n): ").lower() == 's'
                gestor.mostrar_archivos(mostrar_ocultos)
                
            elif opcion == "2":
                termino = input("Ingresa el t√©rmino de b√∫squeda: ").strip()
                if termino:
                    gestor.buscar_archivos(termino)
                else:
                    print("‚ùå Debes ingresar un t√©rmino de b√∫squeda")
                    
            elif opcion == "3":
                confirmar = input("¬øEst√°s seguro de que quieres organizar los archivos? (s/n): ").lower()
                if confirmar == 's':
                    gestor.organizar_archivos()
                else:
                    print("‚ùå Operaci√≥n cancelada")
                    
            elif opcion == "4":
                try:
                    dias = int(input("Ingresa el n√∫mero de d√≠as (por defecto 30): ") or "30")
                    confirmar = input(f"¬øEliminar archivos m√°s antiguos de {dias} d√≠as? (s/n): ").lower()
                    if confirmar == 's':
                        gestor.limpiar_archivos_antiguos(dias)
                    else:
                        print("‚ùå Operaci√≥n cancelada")
                except ValueError:
                    print("‚ùå Debes ingresar un n√∫mero v√°lido")
                    
            elif opcion == "5":
                gestor.mostrar_archivos()
                
            elif opcion == "6":
                gestor.organizacion_automatica_completa()
                
            elif opcion == "7":
                gestor.mostrar_info_sistema()
                
            elif opcion == "8":
                print("üëã ¬°Gracias por usar el Gestor de Archivos de Descargas!")
                break
                
            else:
                print("‚ùå Opci√≥n no v√°lida. Por favor selecciona 1-8")
                
        except KeyboardInterrupt:
            print("\n\nüëã ¬°Hasta luego!")
            break
        except Exception as e:
            print(f"‚ùå Error: {e}")
        
        input("\nPresiona Enter para continuar...")

if __name__ == "__main__":
    main()
